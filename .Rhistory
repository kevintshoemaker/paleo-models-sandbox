############
# SET UP STORAGE STRUCTURES FOR KEY RESULTS METRICS
############
SimInfo <- masterDF[f,]
SimInfo <- as.list(SimInfo)   # coerce to list
MPFilename <- as.character(SimInfo$MPFilename)
name <- gsub(x=MPFilename,pattern=".mp",replacement="",fixed=T)
## add field (matrix) for storing abundance over time for each grid cell
SimInfo$PopAbund <- matrix(0,nrow=NPOPS,ncol=TIMESTEPS)
## add field (vector) for storing the final occupied year for each grid cell
SimInfo$FinalYear <- numeric(NPOPS)
## add field (vector) for storing global abundance over time
SimInfo$TotAbund <- numeric(TIMESTEPS)
## add field (scalar) for storing the year of global extinction
SimInfo$ExtinctionYear <- 0
## add field (list) for storing MCP for each year
if(doMCP) SimInfo$MCPs <- list()
## add field (vector) for storing total range area (MCP) over time
if(doMCP) SimInfo$RangeArea <- numeric(TIMESTEPS)
##add field (scalar) for storing occupancy (number of occupied cells) over time
SimInfo$CellsOccupied <- numeric(TIMESTEPS)
## add field (scalar) for storing occupancy (number of occupied cells) over time
SimInfo$AreaOccupied <- numeric(TIMESTEPS)
###########################
# GET RESULTS
###########################
result = tryCatch({   ## try to catch errors!
### step 1: set up the MP file connection
setwd(thisFolder)
MPcon <- file(MPFilename, 'r')
# while loop: find the string "Pop. 1" [indicates the beginning of the population results]
stringToFind <- "Pop. 1"
basendx <- 0
CHUNKSIZE <- 1000
while (length(input <- readLines(MPcon, n=CHUNKSIZE)) > 0){    # read in chunks until population results are found
temp <- grep(stringToFind,input)
if(length(temp)>0){
ndx <- basendx + temp
pushBack(input[(temp):CHUNKSIZE],MPcon)       # reset the file to where Pop. 1 began
break
}
basendx <- basendx + CHUNKSIZE
}   # end while loop
# read in the population abundances over time
for(pop in 1:NPOPS){
stringToFind <- sprintf("Pop. %s",pop)
temp <- readLines(MPcon,1)
if(temp!=stringToFind){
print(paste("ERROR!","Population #",pop))
break
}
input <- readLines(MPcon, n=TIMESTEPS)
Nvec <- sapply( strsplit(input, " "), function(t) as.numeric(t[1]))
eval(parse(text=sprintf("SimInfo$PopAbund[%s,] <- Nvec",pop)))	   # RESULT: POP ABUNDANCE
}   # end loop through pops
if(isOpen(MPcon)){
close.connection(MPcon)
rm("MPcon")
}
if(exists(MPcon)){
rm("MPcon")
}
# RESULT: TOTAL ABUNDANCE
SimInfo$TotAbund <- apply(SimInfo$PopAbund,2,sum)
# RESULT: GLOBAL EXTINCTION YEAR
SimInfo$ExtinctionYear <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1) SimInfo$ExtinctionYear <- min(which(SimInfo$TotAbund==0))
# RESULT: FINAL OCCUPIED CELL(s)
SimInfo$FinalOccCell <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1){
SimInfo$FinalOccCell <- which(SimInfo$PopAbund[,(SimInfo$ExtinctionYear-1)]>0)
}else{
SimInfo$FinalOccCell <- NA #which(SimInfo$PopAbund[,(TIMESTEPS-1)]>0)
}
# RESULT: FINAL OCCUPIED YEAR FOR EACH POPULATION
SimInfo$FinalYear <- apply(SimInfo$PopAbund,1,function(t) ifelse(sum(t)>0,max(which(t>0)),NA))
# GET XY coords of all occupied sites
occndx <- sapply(as.data.frame(SimInfo$PopAbund),function(t) which(t>1))  # indices of occupied populations for each year
if(doMCP) proj <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
t=1
n <- ifelse(is.na(SimInfo$ExtinctionYear),TIMESTEPS,SimInfo$ExtinctionYear)
for(t in 1:n){
ndx <- occndx[[t]]
# RESULT: MCP OVER TIME
if(doMCP){
if(length(ndx)>=5){       # At least 5 relocations are required to fit an home range
df <- data.frame(x=numeric(length(ndx)),y=0)
df$x <- GridCellAttributes$x.cord[ndx]        # x and y coordinates for all occupied grid cells
df$y <- GridCellAttributes$y.cord[ndx]
df <- SpatialPoints(df,proj4string=proj)
MCP <- mcp(df)
MCPpoly <- MCP@polygons[[1]]@Polygons[[1]]@coords
MCParea <- areaPolygon(MCPpoly)/1e6    # area of the MCP, in km2
SimInfo$MCPs[[t]] <- MCP            # store the MCP as SpatialPolygonsDataFrame object
SimInfo$RangeArea[t] <- MCParea     # store MCP area for each year of the simulation
}else{
SimInfo$MCPs[[t]] <- NA
SimInfo$RangeArea[t] <- NA
}
}
# RESULT: CELLS OCCUPIED OVER TIME
SimInfo$CellsOccupied[t] <- length(ndx)
# RESULT: OCCUPIED AREA OVER TIME AND CELLS OCCUPIED OVER TIME
areaVec <-  GridCellAttributes$Area[ndx]
SimInfo$AreaOccupied[t] <- sum(GridCellAttributes$Area2[ndx])
}
SimInfo$PopAbund <- NULL   ## remove from memory
####################
# SAVE RESULTS TO HARD DISK AND REMOVE FROM RAM
####################
setwd(thisFolder)
filename <- sprintf("%s.RData",name)
eval(parse(text=sprintf("%s <- SimInfo",name)))
eval(parse(text=sprintf("save(%s,file=filename)",name)))   # save to disk
eval(parse(text=sprintf("rm(%s)",name)))   # remove from memory
#}  # end loop through files...
name
}, warning = function(w){
as.character(w)
}, error = function(e){
setwd(thisFolder)
filename <- sprintf("%s.RData",name)
eval(parse(text=sprintf("%s <- e",name)))
eval(parse(text=sprintf("save(%s,file=filename)",name)))   # save to disk
eval(parse(text=sprintf("rm(%s)",name)))   # remove from memory
as.character(e)
}, finally = {
SimInfo$PopAbund <- NULL   ## remove from memory
if(exists("MPcon")){
close.connection(MPcon)
rm("MPcon")
}
})   # end tryCatch
#closeAllConnections()
### return something...
return(result)
}  # end function 'ExtractMPresults'
ExtractMPresults(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth,doMCP=TRUE)
##########################
# This script extracts results from a single MP file generated for the paleo project
#  Authors: Kevin Shoemaker and Damien Fordham
#
# Summary:
#  3 June 2015 -- started scripting
#  15 June 2015 -- tested script, loaded to GitHub
#  1 July 2016  -- modified for parallelization
#TODO
##########################
#########################################################################
#  EXTRACT RESULTS FROM MP FILE
#########################################################################
# Response variables to record
# Grid cell abundance over time
# Timing of grid cell extinction
# Population size over time
# Time of population level extinction
# Sum cell occupancy over time
# MCP over time (maybe save for later)
ExtractMPresults <- function(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth,doMCP=TRUE){
## set up the new folder to store the MP file and associated KCH files... (specifies the niche breadth)
thisFolder <- sprintf("%s\\Sample_%s\\LHS_Sample%s",MP_DIRECTORY,NicheBreadth,f)
############
# SET UP STORAGE STRUCTURES FOR KEY RESULTS METRICS
############
SimInfo <- masterDF[f,]
SimInfo <- as.list(SimInfo)   # coerce to list
MPFilename <- as.character(SimInfo$MPFilename)
name <- gsub(x=MPFilename,pattern=".mp",replacement="",fixed=T)
## add field (matrix) for storing abundance over time for each grid cell
SimInfo$PopAbund <- matrix(0,nrow=NPOPS,ncol=TIMESTEPS)
## add field (vector) for storing the final occupied year for each grid cell
SimInfo$FinalYear <- numeric(NPOPS)
## add field (vector) for storing global abundance over time
SimInfo$TotAbund <- numeric(TIMESTEPS)
## add field (scalar) for storing the year of global extinction
SimInfo$ExtinctionYear <- 0
## add field (list) for storing MCP for each year
if(doMCP) SimInfo$MCPs <- list()
## add field (vector) for storing total range area (MCP) over time
if(doMCP) SimInfo$RangeArea <- numeric(TIMESTEPS)
##add field (scalar) for storing occupancy (number of occupied cells) over time
SimInfo$CellsOccupied <- numeric(TIMESTEPS)
## add field (scalar) for storing occupancy (number of occupied cells) over time
SimInfo$AreaOccupied <- numeric(TIMESTEPS)
###########################
# GET RESULTS
###########################
result = tryCatch({   ## try to catch errors!
### step 1: set up the MP file connection
setwd(thisFolder)
MPcon <- file(MPFilename, 'r')
# while loop: find the string "Pop. 1" [indicates the beginning of the population results]
stringToFind <- "Pop. 1"
basendx <- 0
CHUNKSIZE <- 1000
while (length(input <- readLines(MPcon, n=CHUNKSIZE)) > 0){    # read in chunks until population results are found
temp <- grep(stringToFind,input)
if(length(temp)>0){
ndx <- basendx + temp
pushBack(input[(temp):CHUNKSIZE],MPcon)       # reset the file to where Pop. 1 began
break
}
basendx <- basendx + CHUNKSIZE
}   # end while loop
# read in the population abundances over time
for(pop in 1:NPOPS){
stringToFind <- sprintf("Pop. %s",pop)
temp <- readLines(MPcon,1)
if(temp!=stringToFind){
print(paste("ERROR!","Population #",pop))
break
}
input <- readLines(MPcon, n=TIMESTEPS)
Nvec <- sapply( strsplit(input, " "), function(t) as.numeric(t[1]))
eval(parse(text=sprintf("SimInfo$PopAbund[%s,] <- Nvec",pop)))	   # RESULT: POP ABUNDANCE
}   # end loop through pops
if(isOpen(MPcon)){
close.connection(MPcon)
rm("MPcon")
}
if(exists("MPcon")){
rm("MPcon")
}
# RESULT: TOTAL ABUNDANCE
SimInfo$TotAbund <- apply(SimInfo$PopAbund,2,sum)
# RESULT: GLOBAL EXTINCTION YEAR
SimInfo$ExtinctionYear <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1) SimInfo$ExtinctionYear <- min(which(SimInfo$TotAbund==0))
# RESULT: FINAL OCCUPIED CELL(s)
SimInfo$FinalOccCell <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1){
SimInfo$FinalOccCell <- which(SimInfo$PopAbund[,(SimInfo$ExtinctionYear-1)]>0)
}else{
SimInfo$FinalOccCell <- NA #which(SimInfo$PopAbund[,(TIMESTEPS-1)]>0)
}
# RESULT: FINAL OCCUPIED YEAR FOR EACH POPULATION
SimInfo$FinalYear <- apply(SimInfo$PopAbund,1,function(t) ifelse(sum(t)>0,max(which(t>0)),NA))
# GET XY coords of all occupied sites
occndx <- sapply(as.data.frame(SimInfo$PopAbund),function(t) which(t>1))  # indices of occupied populations for each year
if(doMCP) proj <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
t=1
n <- ifelse(is.na(SimInfo$ExtinctionYear),TIMESTEPS,SimInfo$ExtinctionYear)
for(t in 1:n){
ndx <- occndx[[t]]
# RESULT: MCP OVER TIME
if(doMCP){
if(length(ndx)>=5){       # At least 5 relocations are required to fit an home range
df <- data.frame(x=numeric(length(ndx)),y=0)
df$x <- GridCellAttributes$x.cord[ndx]        # x and y coordinates for all occupied grid cells
df$y <- GridCellAttributes$y.cord[ndx]
df <- SpatialPoints(df,proj4string=proj)
MCP <- mcp(df)
MCPpoly <- MCP@polygons[[1]]@Polygons[[1]]@coords
MCParea <- areaPolygon(MCPpoly)/1e6    # area of the MCP, in km2
SimInfo$MCPs[[t]] <- MCP            # store the MCP as SpatialPolygonsDataFrame object
SimInfo$RangeArea[t] <- MCParea     # store MCP area for each year of the simulation
}else{
SimInfo$MCPs[[t]] <- NA
SimInfo$RangeArea[t] <- NA
}
}
# RESULT: CELLS OCCUPIED OVER TIME
SimInfo$CellsOccupied[t] <- length(ndx)
# RESULT: OCCUPIED AREA OVER TIME AND CELLS OCCUPIED OVER TIME
areaVec <-  GridCellAttributes$Area[ndx]
SimInfo$AreaOccupied[t] <- sum(GridCellAttributes$Area2[ndx])
}
SimInfo$PopAbund <- NULL   ## remove from memory
####################
# SAVE RESULTS TO HARD DISK AND REMOVE FROM RAM
####################
setwd(thisFolder)
filename <- sprintf("%s.RData",name)
eval(parse(text=sprintf("%s <- SimInfo",name)))
eval(parse(text=sprintf("save(%s,file=filename)",name)))   # save to disk
eval(parse(text=sprintf("rm(%s)",name)))   # remove from memory
#}  # end loop through files...
name
}, warning = function(w){
as.character(w)
}, error = function(e){
setwd(thisFolder)
filename <- sprintf("%s.RData",name)
eval(parse(text=sprintf("%s <- e",name)))
eval(parse(text=sprintf("save(%s,file=filename)",name)))   # save to disk
eval(parse(text=sprintf("rm(%s)",name)))   # remove from memory
as.character(e)
}, finally = {
SimInfo$PopAbund <- NULL   ## remove from memory
if(exists("MPcon")){
close.connection(MPcon)
rm("MPcon")
}
})   # end tryCatch
#closeAllConnections()
### return something...
return(result)
}  # end function 'ExtractMPresults'
i
ExtractMPresults(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth,doMCP=TRUE)
f=6;i=6
ExtractMPresults(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth,doMCP=TRUE)
i=5;f=5
ExtractMPresults(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth,doMCP=TRUE)
NicheBreadth <- nb   # set the current niche breadth
cl <- makeCluster(num_cores,outfile="LOG.TXT")
registerDoParallel(cl=cl)    # make the cluster
#######################
## objects to export to each node in the cluster
functionlist <- c('mp.read','mp.read.results')   # , 'mp.write'
filelist <- c('masterDF','NicheBreadth','NPOPS','TIMESTEPS','MP_DIRECTORY','GridCellAttributes')  #'MP_DIRECTORY','template','GENTIME','humanArrival.df','EXE_DIRECTORY','DLL_FILENAME','dispersalFunc.df','DistClasses','NPOPS','DistBins',
objectlist <- c(functionlist,filelist)   # full list of objects to export
#packagelist <- c()
all.mps <- foreach(i = c(1,2,3,4,6,7,8), #1:nrow(masterDF),
.export=objectlist,
.packages = c("sp","adehabitatHR","geosphere"),
.errorhandling=c("pass")
) %dopar% {
ExtractMPresults(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth,doMCP=TRUE)
}
rm(list=ls())
KEVIN = FALSE # TRUE # FALSE  # TRUE
DAMIEN = FALSE
HRA_LAB = FALSE # TRUE
KEVIN_LAB = TRUE
NREPS <- 5     # number of samples to draw from the multivariate uniform prior (LHS) per niche breadth value
NicheBreadths = c(40)                         # NOTE: changed to loop through single NB for testing
if(KEVIN) CODE_DIRECTORY <- "C:\\Users\\Kevin\\GIT\\paleo-models-sandbox"       # code directory should be your local copy of the GitHub repository
if(HRA_LAB) CODE_DIRECTORY <- "C:\\Users\\Akcakaya\\Desktop\\Mammoth Model\\paleo-models-sandbox"
if(DAMIEN) CODE_DIRECTORY <-  "C:\\Users\\Damien Fordham\\Documents\\GitHub\\paleo-models-sandbox"
if(KEVIN_LAB) CODE_DIRECTORY <- "E:\\GIT\\paleo-models-sandbox"
setwd(CODE_DIRECTORY)
source("Rfunctions_PALEO_UTILITY.r")     # Load all functions for Paleo project
source("Rfunction_PALEO_MAKEMPs.r")
source("Rfunction_PALEO_RUNMPs.r")
source("Rfunction_PALEO_EXTRACTRESULTS.r")
SetUpWorkspace()   # function loads packages and sets up the workspace...
num_cores <- detectCores() - 1   # for setting up cluster... leave one core free for windows background processes?
DistBins <- DispersalPreCalculations()
template <- ReadMPTemplate()
nb=60  # for testing...
masterDF <- read.csv("masterDF.csv",header=T)
masterDF
functionlist <- c('mp.read', 'mp.write')
filelist <- c('MP_DIRECTORY','template','GENTIME','humanArrival.df','EXE_DIRECTORY','DLL_FILENAME',
'dispersalFunc.df','DistClasses','NPOPS','DistBins','masterDF','NicheBreadth')
objectlist <- c(functionlist,filelist)   # full list of objects to export
i
i=1
MakeMPfile(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth)
NicheBreadth <- nb   # set the current niche breadth
MakeMPfile(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth)
f
f=i
NicheBreadth
nb=70  # for testing...
NicheBreadth <- nb   # set the current niche breadth
RunMPfile(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth)
f=i
masterDF
i
NicheBreadth
MakeMPfile(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth)
filename <- masterDF$MPFilename[f]
filename
masterDF <- read.csv("masterDF.csv",header=T,stringsAsFactors = F)
setwd(MP_DIRECTORY)
masterDF <- read.csv("masterDF.csv",header=T,stringsAsFactors = F)
setwd(MP_DIRECTORY)
masterDF <- read.csv("masterDF.csv",header=T,stringsAsFactors = F)
MakeMPfile(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth)
filename <- masterDF$MPFilename[f]
filename
filename <- as.character(masterDF$MPFilename[f])
filename <- as.character(masterDF$MPFilename[f])
thisFolder <- sprintf("%s\\Sample_%s\\LHS_Sample%s",MP_DIRECTORY,NicheBreadth,f)
thisFolder
if(is.na(file.info(thisFolder)[1,"isdir"])) dir.create(thisFolder,recursive = T)
initabunds <- writeKCH(toFolder=thisFolder,NicheBreadth=40,Filenum=masterDF$CUTS[f],density=masterDF$DENSITY[f])
thisFolder
NicheBreadth
masterDF$CUTS[f]
masterDF$DENSITY[f]
thisFolder
writeKCH
KCH_DIRECTORY
Filenum
Filenum = 1
density = 1000
toFolder
toFolder=thisFolder
NicheBreadth=NicheBreadth
Filenum=masterDF$CUTS[f]
density=masterDF$DENSITY[f]
initabund <- numeric(NPOPS)
directoryname = sprintf("%s\\Sample_%s\\file_%s",KCH_DIRECTORY,NicheBreadth,Filenum)
directoryname
initabund <- numeric(NPOPS)
initabund
directoryname = sprintf("%s\\Sample_%s\\file_%s",KCH_DIRECTORY,NicheBreadth,Filenum)
directoryname
setwd(directoryname)
i=1
initabunds <- writeKCH(toFolder=thisFolder,NicheBreadth=NicheBreadth,Filenum=masterDF$CUTS[f],density=masterDF$DENSITY[f])
poplist1 <- template$mp.file$PopList
poplist2 <- template$mp.file$PopData_df
poplist2$KchangeSt <- as.character(poplist2$KchangeSt)
poplist2$UD1 <- round(masterDF$HARV[f],3)    # KTS: changed to "HARV" from "HUNT"
poplist2$UD2 <- 0.4  # KTS: this is the "G" parameter in the harvest function that is set to 0.4
poplist2$UD3 <- round(masterDF$HARVZ[f],3)   # KTS: this is the "Z" parameter in the harvest function
poplist2$UD4 <- 0    # this is the "begin harvest year" parameter
poplist2$UD5 <- masterDF$DENSITY[f]   # KTS: did I do this right?
i=1
for(i in 1:NPOPS){
# SET GROWTH RATE
poplist1[[i]]$MaxR <- round(masterDF$RMAX[f],3)
poplist2$MaxR[i] <-  round(masterDF$RMAX[f],3)
# SET KCH FILE
KCHfilename <- sprintf("pop_%s.kch",i)
poplist1[[i]]$KchangeSt <- KCHfilename
poplist2$KchangeSt[i] <-  KCHfilename
# SET INIT ABUND
poplist1[[i]]$InitAbund <- round(initabunds[i])
poplist2$InitAbund[i] <- round(initabunds[i])
# SET ALLEE EFFECT
poplist1[[i]]$localthr <- round(masterDF$ALLEE[f])
poplist2$localthr[i] <- round(masterDF$ALLEE[f])
poplist1[[i]]$IncludeInSum <- TRUE
poplist2$IncludeInSum[i] <- TRUE
# SET INIT HARVEST
mpstarttime <- template$mp.file$MaxDur*GENTIME
harvstarttime <- humanArrival.df$year_min[i] + masterDF$HUMAN[f]*(humanArrival.df$year_max[i]-humanArrival.df$year_min[i])
poplist2$UD4[i] <- round((mpstarttime - harvstarttime)/GENTIME) + 4  # KTS: added "+4" to make human effect have a time lag of 100 years i.e., 5 generations     # KTS: this is now "UD4"
}
# start the new mp file
version <- 60 #template$version
newmp <- template$mp.file
newmp$PopList <- poplist1
newmp$PopData_df <- poplist2
newmp$UseDispDistFunc <- FALSE #TRUE    # now we need to use a dispersal matrix, unfortunately...
newmp$UseCorrDistFunc <- TRUE
# make sure env stoch is lognormal
newmp$Distrib <- "Lognormal"
# set the Dll
newmp$DDforAllPop <- "UD"   # set to user-defined
newmp$UserDllFileName <- sprintf("%s\\%s",EXE_DIRECTORY,DLL_FILENAME)   # TODO: change this?
# SET DISPERSAL
params <- template$mp.file$DispDistFunc
params[1] <- masterDF$DISP1[f]/2                                # "a" parameter describes the proportion staying/leaving a given population
params[2] <- dispersalFunc.df$b[masterDF$dispndx[f]]            # "b" parameter describes the distance moved
params[4] <- dispersalFunc.df$Dmax[masterDF$dispndx[f]]         # "Dmax" parameter limits the maximum distance moved.
newmp$DispDistFunc <- round(params,3)
# ensure that max dist is 95% quantile of dispersal kernel
# compute the dispersal at each distance bin.
# re-weight so that only X% leaves the focal population
# fill in the dispersal kernel.
# b parameter and a parameter must be set so that 95% dispersal quantile at Dmax AND exactly Disp1 % of individs staying in the focal population
#  instead, just use the params from above, and spread out as necessary
dispForDist <- DispersalKernelFunc(DistClasses[-1],params)
dispMatrix <- matrix(0,nrow=NPOPS,ncol=NPOPS)
dispForDist <- dispForDist[-which(dispForDist==0)]
i=1
for(i in 1:NPOPS){
allIndices <- numeric(0)
dispRates <- numeric(0)
j=1
for(j in 1:length(dispForDist)){
if(!is.na(DistBins[[i]][[j]][1])){
allIndices <- c(allIndices,DistBins[[i]][[j]])
dispRates <- c( dispRates,rep(dispForDist[j],times=length(DistBins[[i]][[j]])) )
}
}
multiplier = params[1]/sum(dispRates)
dispRates = dispRates * multiplier   # ensure that total # leaving the population is held constant.
#  sum(dispRates)
dispMatrix[,i][allIndices] <- dispRates
}
newmp$DispMatr <- round(dispMatrix,3)    # fill in the dispersal matrix.
# SET MANAGEMENT ACTIONS (HARVEST)  NOTE: this has changed!!! Now in DLL
newmp$NPopManage <- NPOPS                                       # num of management (harvest) actions equals the number of populations
newmp$NPopManage <- 0
# harvestdf <- newmp$PopManageProp
# mpstarttime <- newmp$MaxDur*GENTIME                             # for translating between human arrival (ybp) and generations in the model
#
# i=1
# for(i in 1:NPOPS){
#   if(i!=1) harvestdf <- rbind(harvestdf,newmp$PopManageProp)
#   harvstarttime <- humanArrival.df$year_min[i] + masterDF$HUMAN[f]*(humanArrival.df$year_max[i]-humanArrival.df$year_min[i])
#   harvestdf$begin.time[i] <- round((mpstarttime - harvstarttime)/GENTIME)   # set start time for harvest
#   harvestdf$end.time[i] <- newmp$MaxDur
#   harvestdf$from.pop[i] <- i                                                # set population ID for management actions
#   harvestdf$to.pop[i] <- i
#   harvestdf$proportion <- round(masterDF$HUNT[f],5)                         # set proportion harvested
# }
#
# newmp$PopManageProp <- harvestdf                                # append all harvest-related parameters
#
# SET INIT ABUND (again)
newmp$StInit[,1] <- round(initabunds)                           # not sure which one is used, so set both at pop and global levels.
# SET TEMP VAR
newmp$SDMatr[[1]]$Matr[1,1] <- round(masterDF$SD[f],3)                    # set temporal variability
# time steps
newmp$MaxDur <- TIMESTEPS
# replicates
newmp$MaxRep <- 1
# correlation (change from default, which is in km)
newmp$CorrDistFunc[2] <- 8
newmp$CorrDistFunc[1] <- 0.99
###############
# write the new mp file
setwd(thisFolder)
mp.write(newmp,version,filename)                   # write MP file

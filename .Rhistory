filelist <- c('masterDF','NicheBreadth','MP_DIRECTORY') #,'template','GENTIME','humanArrival.df','EXE_DIRECTORY','DLL_FILENAME','dispersalFunc.df','DistClasses','NPOPS','DistBins',
objectlist <- c(functionlist,filelist)   # full list of objects to export
all.mps <- foreach(i = 1:nrow(masterDF),
.export=objectlist,
#.packages = c("R2WinBUGS"),
.errorhandling=c("pass")
) %dopar% {
RunMPfile(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth)
}
i=1
f=i
masterDF=masterDF
NicheBreadth=NicheBreadth
NicheBreadth
thisFolder <- sprintf("%s\\Sample_%s\\LHS_Sample%s",MP_DIRECTORY,NicheBreadth,f)
thisFolder
SimInfo <- masterDF[f,]
SimInfo <- as.list(SimInfo)   # coerce to list
MPFilename <- as.character(SimInfo$MPFilename)
name <- gsub(x=MPFilename,pattern=".mp",replacement="",fixed=T)
SimInfo$PopAbund <- matrix(0,nrow=NPOPS,ncol=TIMESTEPS)
## add field (vector) for storing the final occupied year for each grid cell
SimInfo$FinalYear <- numeric(NPOPS)
## add field (vector) for storing global abundance over time
SimInfo$TotAbund <- numeric(TIMESTEPS)
## add field (scalar) for storing the year of global extinction
SimInfo$ExtinctionYear <- 0
### step 1: set up the MP file connection
setwd(thisFolder)
MPcon <- file(MPFilename, 'r')
# while loop: find the string "Pop. 1" [indicates the beginning of the population results]
stringToFind <- "Pop. 1"
basendx <- 0
CHUNKSIZE <- 1000
while (length(input <- readLines(MPcon, n=CHUNKSIZE)) > 0){    # read in chunks until population results are found
temp <- grep(stringToFind,input)
if(length(temp)>0){
ndx <- basendx + temp
pushBack(input[(temp):CHUNKSIZE],MPcon)       # reset the file to where Pop. 1 began
break
}
basendx <- basendx + CHUNKSIZE
}   # end while loop
# read in the population abundances over time
for(pop in 1:NPOPS){
stringToFind <- sprintf("Pop. %s",pop)
temp <- readLines(MPcon,1)
if(temp!=stringToFind){
print(paste("ERROR!","Population #",pop))
break
}
input <- readLines(MPcon, n=TIMESTEPS)
Nvec <- sapply( strsplit(input, " "), function(t) as.numeric(t[1]))
eval(parse(text=sprintf("SimInfo$PopAbund[%s,] <- Nvec",pop)))	   # RESULT: POP ABUNDANCE
}   # end loop through pops
CHUNKSIZE
closeAllConnections()
ExtractMPresults <- function(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth){
## set up the new folder to store the MP file and associated KCH files... (specifies the niche breadth)
thisFolder <- sprintf("%s\\Sample_%s\\LHS_Sample%s",MP_DIRECTORY,NicheBreadth,f)
############
# SET UP STORAGE STRUCTURES FOR KEY RESULTS METRICS
############
SimInfo <- masterDF[f,]
SimInfo <- as.list(SimInfo)   # coerce to list
MPFilename <- as.character(SimInfo$MPFilename)
name <- gsub(x=MPFilename,pattern=".mp",replacement="",fixed=T)
## add field (matrix) for storing abundance over time for each grid cell
SimInfo$PopAbund <- matrix(0,nrow=NPOPS,ncol=TIMESTEPS)
## add field (vector) for storing the final occupied year for each grid cell
SimInfo$FinalYear <- numeric(NPOPS)
## add field (vector) for storing global abundance over time
SimInfo$TotAbund <- numeric(TIMESTEPS)
## add field (scalar) for storing the year of global extinction
SimInfo$ExtinctionYear <- 0
## add field (list) for storing MCP for each year
#SimInfo$MCPs <- list()
## add field (vector) for storing total range area (MCP) over time
#SimInfo$RangeArea <- numeric(TIMESTEPS)
## add field (scalar) for storing occupancy (number of occupied cells) over time
#SimInfo$CellsOccupied <- numeric(TIMESTEPS)
## add field (scalar) for storing occupancy (number of occupied cells) over time
#SimInfo$AreaOccupied <- numeric(TIMESTEPS)
###########################
# GET RESULTS
###########################
### step 1: set up the MP file connection
setwd(thisFolder)
MPcon <- file(MPFilename, 'r')
# while loop: find the string "Pop. 1" [indicates the beginning of the population results]
stringToFind <- "Pop. 1"
basendx <- 0
CHUNKSIZE <- 1000
while (length(input <- readLines(MPcon, n=CHUNKSIZE)) > 0){    # read in chunks until population results are found
temp <- grep(stringToFind,input)
if(length(temp)>0){
ndx <- basendx + temp
pushBack(input[(temp):CHUNKSIZE],MPcon)       # reset the file to where Pop. 1 began
break
}
basendx <- basendx + CHUNKSIZE
}   # end while loop
# read in the population abundances over time
for(pop in 1:NPOPS){
stringToFind <- sprintf("Pop. %s",pop)
temp <- readLines(MPcon,1)
if(temp!=stringToFind){
print(paste("ERROR!","Population #",pop))
break
}
input <- readLines(MPcon, n=TIMESTEPS)
Nvec <- sapply( strsplit(input, " "), function(t) as.numeric(t[1]))
eval(parse(text=sprintf("SimInfo$PopAbund[%s,] <- Nvec",pop)))	   # RESULT: POP ABUNDANCE
}   # end loop through pops
#closeAllConnections()
# RESULT: TOTAL ABUNDANCE
SimInfo$TotAbund <- apply(SimInfo$PopAbund,2,sum)
# RESULT: GLOBAL EXTINCTION YEAR
SimInfo$ExtinctionYear <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1) SimInfo$ExtinctionYear <- min(which(SimInfo$TotAbund==0))
# RESULT: FINAL OCCUPIED CELL(s)
SimInfo$FinalOccCell <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1){
SimInfo$FinalOccCell <- which(SimInfo$PopAbund[,(SimInfo$ExtinctionYear-1)]>0)
}else{
SimInfo$FinalOccCell <- NA #which(SimInfo$PopAbund[,(TIMESTEPS-1)]>0)
}
# RESULT: FINAL OCCUPIED YEAR FOR EACH POPULATION
SimInfo$FinalYear <- apply(SimInfo$PopAbund,1,function(t) ifelse(sum(t)>0,max(which(t>0)),NA))
SimInfo$PopAbund <- NULL
####################
# SAVE RESULTS TO HARD DISK AND REMOVE FROM RAM
####################
setwd(thisFolder)
filename <- sprintf("%s.RData",name)
eval(parse(text=sprintf("%s <- SimInfo",name)))
eval(parse(text=sprintf("save(%s,file=filename)",name)))   # save to disk
eval(parse(text=sprintf("rm(%s)",name)))   # remove from memory
#}  # end loop through files...
#closeAllConnections()
### return something...
return(name)
}  # end function 'ExtractMPresults'
ExtractMPresults <- function(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth){
## set up the new folder to store the MP file and associated KCH files... (specifies the niche breadth)
thisFolder <- sprintf("%s\\Sample_%s\\LHS_Sample%s",MP_DIRECTORY,NicheBreadth,f)
############
# SET UP STORAGE STRUCTURES FOR KEY RESULTS METRICS
############
SimInfo <- masterDF[f,]
SimInfo <- as.list(SimInfo)   # coerce to list
MPFilename <- as.character(SimInfo$MPFilename)
name <- gsub(x=MPFilename,pattern=".mp",replacement="",fixed=T)
## add field (matrix) for storing abundance over time for each grid cell
SimInfo$PopAbund <- matrix(0,nrow=NPOPS,ncol=TIMESTEPS)
## add field (vector) for storing the final occupied year for each grid cell
SimInfo$FinalYear <- numeric(NPOPS)
## add field (vector) for storing global abundance over time
SimInfo$TotAbund <- numeric(TIMESTEPS)
## add field (scalar) for storing the year of global extinction
SimInfo$ExtinctionYear <- 0
## add field (list) for storing MCP for each year
#SimInfo$MCPs <- list()
## add field (vector) for storing total range area (MCP) over time
#SimInfo$RangeArea <- numeric(TIMESTEPS)
## add field (scalar) for storing occupancy (number of occupied cells) over time
#SimInfo$CellsOccupied <- numeric(TIMESTEPS)
## add field (scalar) for storing occupancy (number of occupied cells) over time
#SimInfo$AreaOccupied <- numeric(TIMESTEPS)
###########################
# GET RESULTS
###########################
### step 1: set up the MP file connection
setwd(thisFolder)
MPcon <- file(MPFilename, 'r')
# while loop: find the string "Pop. 1" [indicates the beginning of the population results]
stringToFind <- "Pop. 1"
basendx <- 0
CHUNKSIZE <- 1000
while (length(input <- readLines(MPcon, n=CHUNKSIZE)) > 0){    # read in chunks until population results are found
temp <- grep(stringToFind,input)
if(length(temp)>0){
ndx <- basendx + temp
pushBack(input[(temp):CHUNKSIZE],MPcon)       # reset the file to where Pop. 1 began
break
}
basendx <- basendx + CHUNKSIZE
}   # end while loop
# read in the population abundances over time
for(pop in 1:NPOPS){
stringToFind <- sprintf("Pop. %s",pop)
temp <- readLines(MPcon,1)
if(temp!=stringToFind){
print(paste("ERROR!","Population #",pop))
break
}
input <- readLines(MPcon, n=TIMESTEPS)
Nvec <- sapply( strsplit(input, " "), function(t) as.numeric(t[1]))
eval(parse(text=sprintf("SimInfo$PopAbund[%s,] <- Nvec",pop)))	   # RESULT: POP ABUNDANCE
}   # end loop through pops
#closeAllConnections()
# RESULT: TOTAL ABUNDANCE
SimInfo$TotAbund <- apply(SimInfo$PopAbund,2,sum)
# RESULT: GLOBAL EXTINCTION YEAR
SimInfo$ExtinctionYear <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1) SimInfo$ExtinctionYear <- min(which(SimInfo$TotAbund==0))
# RESULT: FINAL OCCUPIED CELL(s)
SimInfo$FinalOccCell <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1){
SimInfo$FinalOccCell <- which(SimInfo$PopAbund[,(SimInfo$ExtinctionYear-1)]>0)
}else{
SimInfo$FinalOccCell <- NA #which(SimInfo$PopAbund[,(TIMESTEPS-1)]>0)
}
# RESULT: FINAL OCCUPIED YEAR FOR EACH POPULATION
SimInfo$FinalYear <- apply(SimInfo$PopAbund,1,function(t) ifelse(sum(t)>0,max(which(t>0)),NA))
SimInfo$PopAbund <- NULL
####################
# SAVE RESULTS TO HARD DISK AND REMOVE FROM RAM
####################
setwd(thisFolder)
filename <- sprintf("%s.RData",name)
eval(parse(text=sprintf("%s <- SimInfo",name)))
eval(parse(text=sprintf("save(%s,file=filename)",name)))   # save to disk
eval(parse(text=sprintf("rm(%s)",name)))   # remove from memory
#}  # end loop through files...
#closeAllConnections()
### return something...
return(name)
}  # end function 'ExtractMPresults'
NicheBreadth <- nb   # set the current niche breadth
cl <- makeCluster(num_cores,outfile="LOG.TXT")
registerDoParallel(cl=cl)    # make the cluster
functionlist <- c('mp.read','mp.read.results')   # , 'mp.write'
filelist <- c('masterDF','NicheBreadth','NPOPS','TIMESTEPS','MP_DIRECTORY')  #'MP_DIRECTORY','template','GENTIME','humanArrival.df','EXE_DIRECTORY','DLL_FILENAME','dispersalFunc.df','DistClasses','NPOPS','DistBins',
objectlist <- c(functionlist,filelist)   # full list of objects to export
all.mps <- foreach(i = 1:nrow(masterDF),
.export=objectlist,
#.packages = c("R2WinBUGS"),
.errorhandling=c("pass")
) %dopar% {
ExtractMPresults(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth)
}
f
thisFolder <- sprintf("%s\\Sample_%s\\LHS_Sample%s",MP_DIRECTORY,NicheBreadth,f)
SimInfo <- masterDF[f,]
SimInfo <- as.list(SimInfo)   # coerce to list
MPFilename <- as.character(SimInfo$MPFilename)
name <- gsub(x=MPFilename,pattern=".mp",replacement="",fixed=T)
## add field (matrix) for storing abundance over time for each grid cell
SimInfo$PopAbund <- matrix(0,nrow=NPOPS,ncol=TIMESTEPS)
## add field (vector) for storing the final occupied year for each grid cell
SimInfo$FinalYear <- numeric(NPOPS)
## add field (vector) for storing global abundance over time
SimInfo$TotAbund <- numeric(TIMESTEPS)
## add field (scalar) for storing the year of global extinction
SimInfo$ExtinctionYear <- 0
## add field (list) for storing MCP for each year
SimInfo$MCPs <- list()
## add field (vector) for storing total range area (MCP) over time
SimInfo$RangeArea <- numeric(TIMESTEPS)
##add field (scalar) for storing occupancy (number of occupied cells) over time
SimInfo$CellsOccupied <- numeric(TIMESTEPS)
## add field (scalar) for storing occupancy (number of occupied cells) over time
SimInfo$AreaOccupied <- numeric(TIMESTEPS)
setwd(thisFolder)
MPcon <- file(MPFilename, 'r')
stringToFind <- "Pop. 1"
basendx <- 0
CHUNKSIZE <- 1000
while (length(input <- readLines(MPcon, n=CHUNKSIZE)) > 0){    # read in chunks until population results are found
temp <- grep(stringToFind,input)
if(length(temp)>0){
ndx <- basendx + temp
pushBack(input[(temp):CHUNKSIZE],MPcon)       # reset the file to where Pop. 1 began
break
}
basendx <- basendx + CHUNKSIZE
}   # end while loop
for(pop in 1:NPOPS){
stringToFind <- sprintf("Pop. %s",pop)
temp <- readLines(MPcon,1)
if(temp!=stringToFind){
print(paste("ERROR!","Population #",pop))
break
}
input <- readLines(MPcon, n=TIMESTEPS)
Nvec <- sapply( strsplit(input, " "), function(t) as.numeric(t[1]))
eval(parse(text=sprintf("SimInfo$PopAbund[%s,] <- Nvec",pop)))	   # RESULT: POP ABUNDANCE
}   # end loop through pops
SimInfo$TotAbund <- apply(SimInfo$PopAbund,2,sum)
SimInfo$TotAbund
SimInfo$ExtinctionYear <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1) SimInfo$ExtinctionYear <- min(which(SimInfo$TotAbund==0))
SimInfo$ExtinctionYear
SimInfo$TotAbund[TIMESTEPS]
TIMESTEPS
SimInfo$FinalOccCell <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1){
SimInfo$FinalOccCell <- which(SimInfo$PopAbund[,(SimInfo$ExtinctionYear-1)]>0)
}else{
SimInfo$FinalOccCell <- NA #which(SimInfo$PopAbund[,(TIMESTEPS-1)]>0)
}
SimInfo$FinalOccCell
SimInfo$FinalYear <- apply(SimInfo$PopAbund,1,function(t) ifelse(sum(t)>0,max(which(t>0)),NA))
SimInfo$FinalYear
head(SimInfo$PopAbund)
SimInfo$PopAbund
SimInfo$PopAbund[1,1:100]
SimInfo$PopAbund[2,1:100]
SimInfo$PopAbund[3,1:100]
occndx <- sapply(as.data.frame(SimInfo$PopAbund),function(t) which(t>1))  # indices of occupied populations for each year
occndx
occndx[[1]]
proj <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
t=1
ndx <- occndx[[t]]
length(ndx)>=5
df <- data.frame(x=numeric(length(ndx)),y=0)
GridCellAttributes
GridCellAttributes$x.cord[ndx]
df$x <- GridCellAttributes$x.cord[ndx]        # x and y coordinates for all occupied grid cells
df$y <- GridCellAttributes$y.cord[ndx]
df <- SpatialPoints(df,proj4string=proj)
MCP <- mcp(df)
MCPpoly <- MCP@polygons[[1]]@Polygons[[1]]@coords
MCParea <- areaPolygon(MCPpoly)/1e6    # area of the MCP, in km2
SimInfo$MCPs[[t]] <- MCP            # store the MCP as SpatialPolygonsDataFrame object
SimInfo$RangeArea[t] <- MCParea     # store MCP area for each year of the simulation
SimInfo$CellsOccupied[t]
GridCellAttributes$Area2
LoadData <- function(){
###############################
#        LOAD DATA AND OTHER RELEVANT FILES
###############################
setwd(DATA_DIRECTORY)
##########
# Human arrival dates for each population
#humanArrival.df <- read.csv("Human_arrival_7000cells.csv",header=T)  # for each grid cell (population), earliest and latest human arrival dates (years before present))
humanArrival.df <<- read.csv("Mammoth&Human_estimates_v3.csv",header=T)
humanArrival.df <<- humanArrival.df[order(humanArrival.df$Cell.ID),]    # make sure it's ordered the same as the RAMAS model
humanArrival.df$year_min <<- humanArrival.df$Mean.timing.of.human.arrival-2*humanArrival.df$Sd.timing.of.Human.arrival
humanArrival.df$year_max <<- humanArrival.df$Mean.timing.of.human.arrival+2*humanArrival.df$Sd.timing.of.Human.arrival
##########
# For computing real dispersal params
dispersalFunc.df <<- read.csv("dispersalfunctions.csv",header=T)      # links LHS samples to b and Dmax params
#########
# Filenames of all HS files (precursors of KCH files)
#allHSfiles <- list.files(path=HS_DIRECTORY,pattern=".hs")            # char vector of all HS files (not needed??)
#########
# Area and coordinates of all grid cells
#GridCellAttributes <- read.csv("Lattice100km_7000Cells.csv",header=T)  studysite_xy_modified2.csv
GridCellAttributes <<- read.csv("studysite_xy_modified2.csv",header=T)
#GridCellAttributes$RamasID <- as.numeric(gsub("[^0-9]", "", unlist(GridCellAttributes$ID)))
GridCellAttributes$RamasID <<- GridCellAttributes$ID
GridCellAttributes <<- GridCellAttributes[order(GridCellAttributes$RamasID),]    # make sure it's ordered the same as the RAMAS model
NPOPS <<- nrow(GridCellAttributes)  # ensure that this global parameter is correct
##########
# Compute area of each grid cell in km2
GridCellAttributes$Area2 <<- 0
df <- data.frame(x=numeric(4),y=0)
i=1
for(i in 1:nrow(GridCellAttributes)){
xval <- GridCellAttributes$x.cord[i]
yval <- GridCellAttributes$y.cord[i]
xvlb <- xval - 0.5
xvub <- xval + 0.5
yvlb <- yval - 0.5
yvub <- yval + 0.5
df$x <- c(xvlb,xvub,xvub,xvlb)
df$y <- c(yvub,yvub,yvlb,yvlb)
#df <- SpatialPoints(df,proj4string=proj)
GridCellAttributes$Area2[i] <<- areaPolygon(df)/1e6    # area of the MCP, in km2
}
# write to file, with updated areas...
setwd(DATA_DIRECTORY)
write.csv(GridCellAttributes,"GridCellAttributes.csv")
}
SetUpWorkspace()   # function loads packages and sets up the workspace...
GridCellAttributes$Area2
SimInfo$CellsOccupied[t] <- length(ndx)
areaVec <-  GridCellAttributes$Area[ndx]
SimInfo$AreaOccupied[t] <- sum(GridCellAttributes$Area2[ndx])
ExtractMPresults <- function(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth){
## set up the new folder to store the MP file and associated KCH files... (specifies the niche breadth)
thisFolder <- sprintf("%s\\Sample_%s\\LHS_Sample%s",MP_DIRECTORY,NicheBreadth,f)
############
# SET UP STORAGE STRUCTURES FOR KEY RESULTS METRICS
############
SimInfo <- masterDF[f,]
SimInfo <- as.list(SimInfo)   # coerce to list
MPFilename <- as.character(SimInfo$MPFilename)
name <- gsub(x=MPFilename,pattern=".mp",replacement="",fixed=T)
## add field (matrix) for storing abundance over time for each grid cell
SimInfo$PopAbund <- matrix(0,nrow=NPOPS,ncol=TIMESTEPS)
## add field (vector) for storing the final occupied year for each grid cell
SimInfo$FinalYear <- numeric(NPOPS)
## add field (vector) for storing global abundance over time
SimInfo$TotAbund <- numeric(TIMESTEPS)
## add field (scalar) for storing the year of global extinction
SimInfo$ExtinctionYear <- 0
## add field (list) for storing MCP for each year
SimInfo$MCPs <- list()
## add field (vector) for storing total range area (MCP) over time
SimInfo$RangeArea <- numeric(TIMESTEPS)
##add field (scalar) for storing occupancy (number of occupied cells) over time
SimInfo$CellsOccupied <- numeric(TIMESTEPS)
## add field (scalar) for storing occupancy (number of occupied cells) over time
SimInfo$AreaOccupied <- numeric(TIMESTEPS)
###########################
# GET RESULTS
###########################
### step 1: set up the MP file connection
setwd(thisFolder)
MPcon <- file(MPFilename, 'r')
# while loop: find the string "Pop. 1" [indicates the beginning of the population results]
stringToFind <- "Pop. 1"
basendx <- 0
CHUNKSIZE <- 1000
while (length(input <- readLines(MPcon, n=CHUNKSIZE)) > 0){    # read in chunks until population results are found
temp <- grep(stringToFind,input)
if(length(temp)>0){
ndx <- basendx + temp
pushBack(input[(temp):CHUNKSIZE],MPcon)       # reset the file to where Pop. 1 began
break
}
basendx <- basendx + CHUNKSIZE
}   # end while loop
# read in the population abundances over time
for(pop in 1:NPOPS){
stringToFind <- sprintf("Pop. %s",pop)
temp <- readLines(MPcon,1)
if(temp!=stringToFind){
print(paste("ERROR!","Population #",pop))
break
}
input <- readLines(MPcon, n=TIMESTEPS)
Nvec <- sapply( strsplit(input, " "), function(t) as.numeric(t[1]))
eval(parse(text=sprintf("SimInfo$PopAbund[%s,] <- Nvec",pop)))	   # RESULT: POP ABUNDANCE
}   # end loop through pops
#closeAllConnections()
# RESULT: TOTAL ABUNDANCE
SimInfo$TotAbund <- apply(SimInfo$PopAbund,2,sum)
# RESULT: GLOBAL EXTINCTION YEAR
SimInfo$ExtinctionYear <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1) SimInfo$ExtinctionYear <- min(which(SimInfo$TotAbund==0))
# RESULT: FINAL OCCUPIED CELL(s)
SimInfo$FinalOccCell <- NA
if(SimInfo$TotAbund[TIMESTEPS]<1){
SimInfo$FinalOccCell <- which(SimInfo$PopAbund[,(SimInfo$ExtinctionYear-1)]>0)
}else{
SimInfo$FinalOccCell <- NA #which(SimInfo$PopAbund[,(TIMESTEPS-1)]>0)
}
# RESULT: FINAL OCCUPIED YEAR FOR EACH POPULATION
SimInfo$FinalYear <- apply(SimInfo$PopAbund,1,function(t) ifelse(sum(t)>0,max(which(t>0)),NA))
# GET XY coords of all occupied sites
occndx <- sapply(as.data.frame(SimInfo$PopAbund),function(t) which(t>1))  # indices of occupied populations for each year
proj <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
t=1
for(t in 1:(SimInfo$ExtinctionYear-1)){
ndx <- occndx[[t]]
# RESULT: MCP OVER TIME
if(length(ndx)>=5){       # At least 5 relocations are required to fit an home range
df <- data.frame(x=numeric(length(ndx)),y=0)
df$x <- GridCellAttributes$x.cord[ndx]        # x and y coordinates for all occupied grid cells
df$y <- GridCellAttributes$y.cord[ndx]
df <- SpatialPoints(df,proj4string=proj)
MCP <- mcp(df)
MCPpoly <- MCP@polygons[[1]]@Polygons[[1]]@coords
MCParea <- areaPolygon(MCPpoly)/1e6    # area of the MCP, in km2
SimInfo$MCPs[[t]] <- MCP            # store the MCP as SpatialPolygonsDataFrame object
SimInfo$RangeArea[t] <- MCParea     # store MCP area for each year of the simulation
}else{
SimInfo$MCPs[[t]] <- NA
SimInfo$RangeArea[t] <- NA
}
# RESULT: CELLS OCCUPIED OVER TIME
SimInfo$CellsOccupied[t] <- length(ndx)
# RESULT: OCCUPIED AREA OVER TIME AND CELLS OCCUPIED OVER TIME
areaVec <-  GridCellAttributes$Area[ndx]
SimInfo$AreaOccupied[t] <- sum(GridCellAttributes$Area2[ndx])
}
SimInfo$PopAbund <- NULL   ## remove from memory
####################
# SAVE RESULTS TO HARD DISK AND REMOVE FROM RAM
####################
setwd(thisFolder)
filename <- sprintf("%s.RData",name)
eval(parse(text=sprintf("%s <- SimInfo",name)))
eval(parse(text=sprintf("save(%s,file=filename)",name)))   # save to disk
eval(parse(text=sprintf("rm(%s)",name)))   # remove from memory
#}  # end loop through files...
#closeAllConnections()
### return something...
return(name)
}  # end function 'ExtractMPresults'
setwd(MP_DIRECTORY)
masterDF <- read.csv("masterDF.csv",header=T)
nfiles <- nrow(masterDF)
nb=70  # for testing...
NicheBreadth <- nb   # set the current niche breadth
cl <- makeCluster(num_cores,outfile="LOG.TXT")
registerDoParallel(cl=cl)    # make the cluster
functionlist <- c('mp.read','mp.read.results')   # , 'mp.write'
filelist <- c('masterDF','NicheBreadth','NPOPS','TIMESTEPS','MP_DIRECTORY')  #'MP_DIRECTORY','template','GENTIME','humanArrival.df','EXE_DIRECTORY','DLL_FILENAME','dispersalFunc.df','DistClasses','NPOPS','DistBins',
objectlist <- c(functionlist,filelist)   # full list of objects to export
all.mps <- foreach(i = 1:nrow(masterDF),
.export=objectlist,
#.packages = c("R2WinBUGS"),
.errorhandling=c("pass")
) %dopar% {
ExtractMPresults(f=i,masterDF=masterDF,NicheBreadth=NicheBreadth)
}

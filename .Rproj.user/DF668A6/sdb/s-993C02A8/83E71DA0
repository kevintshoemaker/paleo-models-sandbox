{
    "collab_server" : "",
    "contents" : "\n###############\n#### UTILITY FUNCTIONS FOR PALEO MODELS\n###############\n\n\n\n\n###########\n## FUNCTION \"MakeLHSSamples\"\n##\n## Samples from the uniform LHS and translates into desired parameter space\n##  Returns a master data frame that will specify all MP files to be run\n###########\n\n\n###############################\n#        SPECIFY PARAMETER RANGES\n################################\n\nMakeLHSSamples <- function(nicheBreadthDir,NicheBreadth){\n  \n  LHSParms <- list()    # initialize the container for parameter bounds\n  \n  setwd(nicheBreadthDir)   \n  nCUTS <- length(grep(\"file_\",list.dirs(path=nicheBreadthDir,recursive=F)))   #number of \"cuts\"  pattern=\"File_\" \t\n  LHSParms <- specifyLHSParam(paramslist=LHSParms,name=\"CUTS\",type=\"CAT\",lb=1,ub=nCUTS)\n  \n  ####  RMAX\n  LHSParms <- specifyLHSParam(LHSParms,\"RMAX\",type=\"CONT\",lb=1.28,ub=6.84)\n  \n  #### TEMPORAL VARIABILITY\n  LHSParms <- specifyLHSParam(LHSParms,\"SD\",type=\"CONT\",lb=0,ub=0.175)\n  \n  ### ALLEE EFFECT    0 to 100 individuals...  \n  LHSParms <- specifyLHSParam(LHSParms,\"ALLEE\",type=\"CONT\",lb=0,ub=500)       # KTS: changed to 500\n  \n  ### DENSITY PER 100kmX100km GRID CELL\n  LHSParms <- specifyLHSParam(LHSParms,\"DENSITY\",type=\"CONT\",lb=625,ub=10000)     # was 1000 to 40000  \n  \n  ### DISPERSAL #1: PROPORTION DISPERSING (used to compute \"a\" parameter.  a = p/2)\n  LHSParms <- specifyLHSParam(LHSParms,\"DISP1\",type=\"CONT\",lb=0.05,ub=0.25)\n  \n  ### DISPERSAL #2: MAXIMUM DISTANCE MOVED  [will translate into b and DMax according to Resit's pre-calculations]\n  LHSParms <- specifyLHSParam(LHSParms,\"DISP2\",type=\"CONT\",lb=100,ub=500) \n  \n  ### HUNTING  (proportion harvested per year)   # NOTE: this is specified on an annual time scale (not generational). \n  LHSParms <- specifyLHSParam(LHSParms,\"HARV\",type=\"CONT\",lb=0,ub=0.05)\n  \n  ### DENSITY DEPENDENCE ON HARVEST (y intercept of the harvest rate/abundance relationship)\n  \n  #  # HUNTDD_posvals <- c(seq(-0.05,0,length=10),seq(0.1,1,length=10),seq(1.1,2,length=10))\n  # LHSParms <- specifyLHSParam(LHSParms,\"HUNTDD\",type=\"CONT\",lb=-0.05,ub=2)\n  \n  LHSParms <- specifyLHSParam(LHSParms,\"HARVZ\",type=\"CONT\",lb=1,ub=2)\n  \n  #### HUMAN ARRIVAL (0 represents lower bound on a per-population basis, 1 represents upper bound)\n  LHSParms <- specifyLHSParam(LHSParms,\"HUMAN\",type=\"CONT\",lb=0,ub=1)    # NOTE: was \"CAT\" not sure why\n  \n  ##################\n  ##### GENERATE LATIN HYPERCUBE SAMPLE\n  \n  nVars <- length(names(LHSParms))  \n  \n  LHS <- randomLHS(NREPS, nVars )   # generate multiple samples from parameter space according to a LHS sampling scheme\n  \n  masterDF <- as.data.frame(LHS)    #  storage container (data frame) to record relevant details for each MP file. Rows:MP file/LHS samples. Cols: relevant variables\n  \n  \n  ### translate raw lhs samples into desired parameter space\n  colnames(masterDF) <- names(LHSParms)\n  parm=1\n  for(parm in 1:nVars){\n    if(LHSParms[[parm]]$type==\"CONT\"){\n      masterDF[,parm] <- LHSParms[[parm]]$lb + LHS[,parm]*(LHSParms[[parm]]$ub-LHSParms[[parm]]$lb)\n    }\n    if(LHSParms[[parm]]$type==\"CAT\"){\n      masterDF[,parm] <- ceiling(LHSParms[[parm]]$lb + LHS[,parm]*(LHSParms[[parm]]$ub-LHSParms[[parm]]$lb))\n    }\n  }\n  \n  masterDF$dispndx <- as.numeric(cut(masterDF$DISP2,breaks=c(dispersalFunc.df$Distl,Inf)))   \n  \n  #masterDF$HUNTDD <- HUNTDD_posvals[masterDF$HUNTDD]    # value input into RAMAS DLL for density dependent hunting \n\n  masterDF$NicheBreadth <- NicheBreadth   # set the niche breadth\n  \n  #######  Add the MP filename to the masterDF data frame\n  \n  masterDF$MPFilename <- \"\"\n  for(i in 1:nrow(masterDF)){\n    masterDF$MPFilename[i] <- sprintf(\"NicheBreadth%s_LHS_Sample%s.mp\",NicheBreadth,i)\n  }\n  \n  setwd(MP_DIRECTORY)\n  ## name file for LHS parameters \n  write.csv(masterDF,sprintf(\"masterDF_prelim%s.csv\",NicheBreadth),row.names=F)\n  \n  return(masterDF)\n}\n\n###########\n## FUNCTION \"ReadMPTemplate\"\n##\n## Reads in a template MP file for later use...\n###########\n\nReadMPTemplate <- function(){\n  #### read in template MP file\n  setwd(MP_DIRECTORY)\n  mpfilein <- MP_TEMPLATE\n  template <- mp.read(mpfilein)   # read in template\n  return(template)\n}\n\n###########\n## FUNCTION \"DispersalPreCalculations\"\n##\n## Loads all required packages for paleo project\n###########\n\n\n#############################\n# DISPERSAL PRE-CALCULATIONS (only needs to be done once)\n#############################\n\n\nDispersalPreCalculations <- function(){\n  #?distMeeus\n  #?distm\n  \n  #distMeeus(GridCellAttributes[1,c(1,2)],GridCellAttributes[2,c(1,2)])/1000\n  \n  # NPOPS*NPOPS matrix of pairwise distances between grid centroids (km) [uses geosphere package]\n  distmatrix <- distm(GridCellAttributes[,c(1,2)],GridCellAttributes[,c(1,2)],fun=distMeeus)/1000\n  \n  # Distance classes for computing dispersal matrix (in km)\n  MinDist <- 100\n  MaxDist <- 500\n  BinSize <- 20\n  DistClasses <<- c(1,seq(MinDist,MaxDist,BinSize))\n  \n  DistBins <- list()\n  for(p in 1:NPOPS){\n    # Determine the distance between this population and all others, in km\n    DistBins[[p]] <- list()\n    for(b in 2:length(DistClasses)){\n      inBin <- which( (distmatrix[,p]>DistClasses[b-1]) & (distmatrix[,p]<=DistClasses[b]) )\n      if(length(inBin)>0){\n        DistBins[[p]][[b-1]] <- inBin\n      }else{\n        DistBins[[p]][[b-1]] <- NA\n      }\n    }\n  }\n  \n  rm(distmatrix)   # save memory and remove the distance matrix...\n\n  return(DistBins)\n}\n\n###########\n## FUNCTION \"LoadPackages\"\n##\n## Loads all required packages for paleo project\n###########\n\nLoadPackages <- function(){\n  #############################\n  #  LOAD PACKAGES\n  #############################\n  \n  loadPackage(\"fields\")     # note: loadPackage should install the package from CRAN automatically if it is not already installed\n  loadPackage(\"lhs\")\n  loadPackage(\"RCurl\")\n  loadPackage(\"geosphere\")\n  loadPackage(\"parallel\")\n  loadPackage(\"doParallel\")\n  loadPackage(\"adehabitatHR\")\n  \n  # Read in the functions for reading and writing MP files, from Matt Lammens\n  \n  baseurl = \"https://raw.githubusercontent.com/mlammens/SACode_Sandbox/master/\"\t\t\t\t \n  source_github(baseurl,\"mp.write.r\")\n  source_github(baseurl,\"mp.read.r\")\n  source_github(baseurl,\"metapopversion.r\")\n  source_github(baseurl,\"fill.matrix.df.r\")\n  source_github(baseurl,\"mp.read.results.r\")\n\n}\n\n\n###########\n## FUNCTION \"LoadData\"\n##\n## Loads all required data for paleo project\n###########\n\nLoadData <- function(){\n  ###############################\n  #        LOAD DATA AND OTHER RELEVANT FILES\n  ###############################\n  \n  setwd(DATA_DIRECTORY)\n  \n  ##########\n  # Human arrival dates for each population\n  #humanArrival.df <- read.csv(\"Human_arrival_7000cells.csv\",header=T)  # for each grid cell (population), earliest and latest human arrival dates (years before present))\n  humanArrival.df <<- read.csv(\"Mammoth&Human_estimates_v3.csv\",header=T)\n  humanArrival.df <<- humanArrival.df[order(humanArrival.df$Cell.ID),]    # make sure it's ordered the same as the RAMAS model\n  \n  humanArrival.df$year_min <<- humanArrival.df$Mean.timing.of.human.arrival-2*humanArrival.df$Sd.timing.of.Human.arrival\n  humanArrival.df$year_max <<- humanArrival.df$Mean.timing.of.human.arrival+2*humanArrival.df$Sd.timing.of.Human.arrival\n  \n  ##########\n  # For computing real dispersal params \n  dispersalFunc.df <<- read.csv(\"dispersalfunctions.csv\",header=T)      # links LHS samples to b and Dmax params\n  \n  #########\n  # Filenames of all HS files (precursors of KCH files)\n  #allHSfiles <- list.files(path=HS_DIRECTORY,pattern=\".hs\")            # char vector of all HS files (not needed??)\n  \n  #########\n  # Area and coordinates of all grid cells\n  #GridCellAttributes <- read.csv(\"Lattice100km_7000Cells.csv\",header=T)  studysite_xy_modified2.csv\n  GridCellAttributes <<- read.csv(\"studysite_xy_modified2.csv\",header=T)  \n  \n  #GridCellAttributes$RamasID <- as.numeric(gsub(\"[^0-9]\", \"\", unlist(GridCellAttributes$ID)))\n  GridCellAttributes$RamasID <<- GridCellAttributes$ID\n  GridCellAttributes <<- GridCellAttributes[order(GridCellAttributes$RamasID),]    # make sure it's ordered the same as the RAMAS model\n  \n  NPOPS <<- nrow(GridCellAttributes)  # ensure that this global parameter is correct\n  \n  ##########\n  # Compute area of each grid cell in km2\n  GridCellAttributes$Area2 <- 0\n  df <- data.frame(x=numeric(4),y=0)\n  i=1\n  for(i in 1:nrow(GridCellAttributes)){\t\n    xval <- GridCellAttributes$x.cord[i]\n    yval <- GridCellAttributes$y.cord[i]\n    xvlb <- xval - 0.5\n    xvub <- xval + 0.5\n    yvlb <- yval - 0.5\n    yvub <- yval + 0.5\n    df$x <- c(xvlb,xvub,xvub,xvlb)\n    df$y <- c(yvub,yvub,yvlb,yvlb)\n    #df <- SpatialPoints(df,proj4string=proj)\n    GridCellAttributes$Area2[i] <- areaPolygon(df)/1e6    # area of the MCP, in km2\n  }\n  \n  # write to file, with updated areas...\n  setwd(DATA_DIRECTORY)\n  write.csv(GridCellAttributes,\"GridCellAttributes.csv\")\n  \n}\n\n###########\n## FUNCTION \"SetUpWorkspace\"\n##\n## Sets up the R workspace with necessary global variables\n###########\n\nSetUpWorkspace <- function(){\n  if(KEVIN) BASE_DIRECTORY <<- \"C:\\\\Users\\\\Kevin\\\\Dropbox\\\\Damien Fordham\\\\Mammoth Model\"  \n  if(DAMIEN) BASE_DIRECTORY <<- \"E:\\\\Mammoth model\"\n  if(HRA_LAB) BASE_DIRECTORY <<- \"C:\\\\Users\\\\Akcakaya\\\\Desktop\\\\Mammoth Model\"\n  if(KEVIN_LAB) BASE_DIRECTORY <<- \"E:\\\\Dropbox\\\\Damien Fordham\\\\Mammoth Model\"\n  \n  \n  ######## BELOW DOESNT NEED TO BE CHANGED\n  DATA_DIRECTORY <<- paste(BASE_DIRECTORY,\"\\\\data\",sep=\"\")                         # directory for storing relevant data (CSV files)\n  if(is.na(file.info(DATA_DIRECTORY)[1,\"isdir\"])) dir.create(DATA_DIRECTORY)\n  \n  MP_DIRECTORY <<- paste(BASE_DIRECTORY,\"\\\\mpfiles\",sep=\"\")                        # directory for storing and running MP files \n  if(is.na(file.info(MP_DIRECTORY)[1,\"isdir\"])) dir.create(MP_DIRECTORY)\n  \n  EXE_DIRECTORY <<- paste(BASE_DIRECTORY,\"\\\\EXEs\",sep=\"\")                        # directory for storing DLLs and EXE files \n  if(is.na(file.info(EXE_DIRECTORY)[1,\"isdir\"])) dir.create(EXE_DIRECTORY)\n  \n  FIGURES_DIRECTORY <<- paste(BASE_DIRECTORY,\"\\\\figures\\\\raw\",sep=\"\")              # directory for storing raw figures \n  if(is.na(file.info(FIGURES_DIRECTORY)[1,\"isdir\"])) dir.create(FIGURES_DIRECTORY)\n  \n  HS_DIRECTORY <<- paste(BASE_DIRECTORY,\"\\\\hs\",sep=\"\")                             # directory for storing habitat suitability files (used for creating KCH files )\n  if(is.na(file.info(HS_DIRECTORY)[1,\"isdir\"])) dir.create(HS_DIRECTORY)\n  \n  KCH_DIRECTORY <<- paste(BASE_DIRECTORY,\"\\\\KCHFiles\",sep=\"\")                            # directory for storing habitat suitability files\n  if(is.na(file.info(KCH_DIRECTORY)[1,\"isdir\"])) dir.create(KCH_DIRECTORY)\n  \n  RESULTS_DIRECTORY <<- paste(BASE_DIRECTORY,\"\\\\results\",sep=\"\")                             # directory for storing habitat suitability files (used for creating KCH files )\n  if(is.na(file.info(RESULTS_DIRECTORY)[1,\"isdir\"])) dir.create(RESULTS_DIRECTORY)\n  \n  ############\n  ## GLOBAL PARAMETERS\n\n  TIMESTEPS <<- 3201 # set according to length of the simulation \n  GENTIME <<- 25\n  MP_TEMPLATE <<- \"NewMammothTemplate.mp\"      # template MP file\n  DLL_FILENAME <<- \"Mammoth2.dll\"    # KTS: changed to \"Mammoth2.dll\" from \"Mammoth.dll\"\n  VERBOSE=FALSE\n  \n  # save global params\n  setwd(DATA_DIRECTORY)\n  save(NREPS,TIMESTEPS,GENTIME,MP_TEMPLATE,file=\"GlobalParams.RData\")\n  \n  LoadPackages()  # load all packages\n  LoadData()      # load all data\n  \n}  \n\n\n###########\n## FUNCTION \"LoadPackages\"\n##\n## Basic dispersal function in Ramas...\n###########\n\nnegexp <- function(distance,alpha, beta) {\n   alpha*exp((-1*(distance))/beta)   \n}\n\n\n###########\n## FUNCTION \"LoadPackages\"\n##\n## Visualize basic dispersal function in Ramas...\n###########\n\nvisualizeDispersalFunction <- function(alpha, beta) {\n graphics.off()\n a = alpha      # dispersal parameters\n b = beta      \n curve(negexp(x,a,b),col=\"red\",lwd=2,0,7)\n}\n\n###########\n## FUNCTION \"specifyLHSParam\"\n##\n## Information necessary to translate standard uniform LHS sample into parameters of interest for paleo project \n###########\n\nspecifyLHSParam <- function(paramslist,name,type,lb,ub){\n    newlist <- paramslist\n\teval(parse(text=sprintf(\"newlist$%s <- list()\",name)))\n\teval(parse(text=sprintf(\"newlist$%s$type <- \\\"%s\\\"\",name,type)))\n\teval(parse(text=sprintf(\"newlist$%s$lb <- %s\",name,lb)))\n\teval(parse(text=sprintf(\"newlist$%s$ub <- %s\",name,ub))) \t\n\treturn(newlist)\n}\n\n\n\n\n###########\n## FUNCTION \"writeKCH\"\n##\n## Selects raw KCH files that Damien built (0 to 1), translates to real abundance, c\n## computes initial abundance, and moves KCH files into the necessary folder for processing (same folder where mp file is located)\n###########\n\nwriteKCH <- function(toFolder=thisFolder,NicheBreadth=40,Filenum = 1,density = 1000){\n\tinitabund <- numeric(NPOPS)\n\tdirectoryname = sprintf(\"%s\\\\Sample_%s\\\\file_%s\",KCH_DIRECTORY,NicheBreadth,Filenum)\n\tsetwd(directoryname)\n\ti=1\n\tfor(i in 1:NPOPS){\n\t  KCHfilename = sprintf(\"pop_%s.kch\",i)\n\t  setwd(directoryname)\n\t  K = read.table(KCHfilename,header=F)[,1]\n\t  K=K*density   # convert to abundance\n\t  initabund[i] = K[1]\n\t  setwd(toFolder)\n\t  write.table(K,file=KCHfilename,row.names=F,col.names=F)\n\t}\n\treturn(initabund)\n}\n\n###########\n## FUNCTION \"loadPackage\"\n##\n## GENERIC FUNCTION FOR INSTALLING/LOADING PACKAGES FROM CRAN\n##\n###########\n\nloadPackage <- function(pkg){\n\n  if(pkg %in% rownames(installed.packages()) == FALSE) {suppressMessages(suppressWarnings(install.packages(pkg)))}\n  eval(parse(text=sprintf(\"suppressMessages(suppressWarnings(require(%s)))\",pkg)), envir= .GlobalEnv)\n\n}\n\n###########\n## FUNCTION \"loadPackage\"\n##\n## GENERIC FUNCTION FOR INSTALLING/LOADING SOURCE CODE FROM GITHUB\n##\n###########\n\nsource_github <- function(baseurl,scriptname) {\n  # load package\n   suppressMessages(suppressWarnings(require(RCurl)))\n \n  # read script lines from website\n  url <- sprintf(\"%s%s\",baseurl,scriptname)\n  script <- getURL(url, ssl.verifypeer = FALSE)\n  \n  script <- gsub(\"\\r\\n\", \"\\n\", script)     # get rid of carriage returns (not sure why this is necessary...)\n \n  # parse lines and evaluate in the global environement\n  eval(parse(text = script), envir= .GlobalEnv)\n}\n\n\n###########\n## FUNCTION \"DispersalKernelFunc\"\n##\n## FUNCTION FOR CONVERTING DISTANCES TO DISPERSAL RATES USING RAMAS DISPERSAL PARAMS\n##\n###########\n\n DispersalKernelFunc <- function(dist,params){   \n    ifelse(dist<=params[4],params[1]*exp((-dist^params[3])/params[2]),0)\n  }\n \n#########################\n ### DEPRECATED FUNCTIONS\n#########################\n \n #### function to set up and write KCH files\n #      and... determine initial abundance for each population\n #      remember- we will need to scale by area... \n \n # writeKCH <- function(HSnum = 1,density = 1000,areas=rep(1000,times=NPOPS)){\n # \tinitabund <- numeric(NPOPS)\n # \tfor(i in 1:NPOPS){\n # \t  HSfilename = sprintf(\"pop%s_rep%s.hs\",i,HSnum)\n # \t  KCHfilename = sprintf(\"pop%s_rep%s.kch\",i,HSnum)\n # \t  setwd(HS_DIRECTORY)\n # \t  hs = read.table(HSfilename,header=F)[,1]\n # \t  initabund[i] = hs[1]*density*(areas[i]/10000)\n # \t  K = round(hs*density*(areas[i]/10000))\n # \t  setwd(MP_DIRECTORY)\n # \t  write.table(K,file=KCHfilename,row.names=F,col.names=F)\n # \t}\n # \treturn(initabund)\n # }\n\n\n\n\n",
    "created" : 1476732909591.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1441223839",
    "id" : "83E71DA0",
    "lastKnownWriteTime" : 1476732969,
    "last_content_update" : 1476732969463,
    "path" : "E:/GIT/paleo-models-sandbox/Rfunctions_PALEO_UTILITY.r",
    "project_path" : "Rfunctions_PALEO_UTILITY.r",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}